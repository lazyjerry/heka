<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0,
             minimum-scale=1.0,
             maximum-scale=1.0,
             user-scalable=no">
        <title>2025 蛇年賀卡 - 來自 Jerry 的祝福</title>
        <style>
        /* ===== 通用樣式 ===== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* 背景：線性漸層 */
        body {
            height: 100vh;
            overflow: hidden;
            /* 或 auto，看需求 */
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: sans-serif;
            background: linear-gradient(90deg, #fec5e5, #b3f4d8, #b3d4f4);
            overscroll-behavior-y: contain;
            overscroll-behavior-x: contain;
        }

        /*
      為了電腦版(橫向螢幕)也能完整呈現名片，
      並保持長寬比例一致，新增兩個媒體查詢：
      - 螢幕 寬/高 >= 664/1129 (較寬): 以高度為主
      - 否則(較窄): 以寬度為主
    */
        @media (min-aspect-ratio: 664/1129) {
            .card-container {
                width: auto;
                height: 90vh;
            }
        }

        @media (max-aspect-ratio: 664/1129) {
            .card-container {
                width: 70vw;
                min-width: 300px;
                height: auto;
            }
        }

        .card-container {
            /* 保持名片比例 */
            aspect-ratio: 664 / 1129;
            perspective: 1000px;
            position: relative;
            overflow: visible;
        }

        .card {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            /* 一開始顯示正面 */
            transform: rotate(0deg) scale(1);
            transition: transform 0.5s ease;
            user-select: none;

            /* 外框或陰影 */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            background-color: #fff;
        }

        .card-side {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            backface-visibility: hidden;
            border-radius: 10px;
        }

        /* 正面 */
        .front {
            transform: rotateY(0deg);
        }

        /* 背面 (預設水平翻) */
        .back {
            transform: rotateY(180deg);
        }

        .card-side img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
            -webkit-user-drag: none;
            user-drag: none;
        }
        </style>
    </head>

    <body>
        <!-- 名片容器 -->
        <div class="card-container">
            <div class="card" id="businessCard">
                <div class="card-side front">
                    <img src="1.jpg" alt="Front Side" />
                </div>
                <div class="card-side back" id="backSide">
                    <img src="2.jpg" alt="Back Side" />
                </div>
            </div>
        </div>
        <script>
        /*********************************************
         * 名片翻轉 + 雙指縮放 (Pinch Zoom) 邏輯
         *********************************************/
        const card = document.getElementById('businessCard');
        const backSide = document.getElementById('backSide');

        let isDragging = false;
        let startX = 0,
            startY = 0;
        let flipDirection = null;
        let currentAngle = 0;
        const threshold = 90;

        /* 縮放相關變數 */
        let currentScale = 1; // 目前縮放比例
        const MIN_SCALE = 0.5,
            MAX_SCALE = 2.5;
        let pinchStartDist = 0; // 兩指起始距離

        /*
          加入 isOnBack，用來判斷「卡片已水平翻到背面」。
          若翻到背面後上下滑動，就轉成上下顛倒。
        */
        let isOnBack = false; // 是否已翻到背面 (水平)

        // 計算兩指距離
        function getDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // 初始化翻轉
        function startFlip(x, y) {
            isDragging = true;
            startX = x;
            startY = y;
            flipDirection = null;
            card.style.transition = ""; // 拖曳過程無 transition
        }

        // 翻轉中
        function moveFlip(x, y) {
            const deltaX = x - startX;
            const deltaY = y - startY;

            /*
              (a) 若已在背面且先前是水平翻 (isOnBack = true)，
                  一旦偵測到「明顯上下拖動」，就改成上下翻轉，
                  讓背面上下顛倒 (不再幫 .back 做 rotateX(180deg) 校正)。
            */
            if (isOnBack && !flipDirection) {
                if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 10) {
                    flipDirection = 'vertical';
                    // 這裡移除原先的 backSide.style.transform = 'rotateX(180deg)';
                    // 不做任何校正 => 最終會上下顛倒
                    backSide.style.transform = '';
                }
            }

            // (b) 若尚未決定翻方向 (flipDirection=null)，用原邏輯判斷
            if (!flipDirection) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    flipDirection = 'horizontal';
                    backSide.style.transform = 'rotateY(180deg)';
                } else {
                    flipDirection = 'vertical';
                    // 同樣註解掉，避免背面自動校正
                    // backSide.style.transform = 'rotateX(180deg)';
                    backSide.style.transform = '';
                }
            }

            // (c) 計算旋轉角度
            if (flipDirection === 'horizontal') {
                currentAngle = deltaX * 0.5;
                currentAngle = Math.max(-180, Math.min(180, currentAngle));
                card.style.transform = `rotateY(${currentAngle}deg) scale(${currentScale})`;
            } else {
                currentAngle = -deltaY * 0.5;
                currentAngle = Math.max(-180, Math.min(180, currentAngle));
                card.style.transform = `rotateX(${currentAngle}deg) scale(${currentScale})`;
            }
        }

        // 結束翻轉
        function endFlip() {
            isDragging = false;
            if (Math.abs(currentAngle) > threshold) {
                currentAngle = currentAngle > 0 ? 180 : -180;
            } else {
                currentAngle = 0;
            }
            card.style.transition = "transform 0.5s ease";

            if (flipDirection === 'horizontal') {
                card.style.transform = `rotateY(${currentAngle}deg) scale(${currentScale})`;
                // 水平翻到 ±180 => 背面朝上
                isOnBack = (Math.abs(currentAngle) === 180);
            } else if (flipDirection === 'vertical') {
                card.style.transform = `rotateX(${currentAngle}deg) scale(${currentScale})`;
                // 垂直翻 ±180 => 背面上下顛倒 (但不再設定 isOnBack)
                isOnBack = false;
            }

            // 完成動畫後移除 transition
            setTimeout(() => {
                card.style.transition = "";
            }, 500);
        }

        // 手指事件：單指翻轉、雙指縮放
        function onTouchStart(e) {
            const t = e.touches[0];
            startFlip(t.clientX, t.clientY);

        }

        function onTouchMove(e) {
            const t = e.touches[0];
            moveFlip(t.clientX, t.clientY);

        }

        function onTouchEnd(e) {
            if (e.touches.length === 0) {
                // 所有手指離開
                if (isDragging) {
                    endFlip();
                } else {
                    // 結束縮放：記錄當前縮放
                    const transformValue = card.style.transform;
                    const match = transformValue.match(/scale\(([\d.]+)\)/);
                    if (match) {
                        currentScale = parseFloat(match[1]);
                    }
                }
            }
        }

        card.addEventListener('touchstart', onTouchStart, { passive: true });
        card.addEventListener('touchmove', onTouchMove, { passive: false });
        card.addEventListener('touchend', onTouchEnd);

        // 滑鼠事件 (桌面版翻轉)
        let mouseDown = false;
        card.addEventListener('mousedown', e => {
            e.preventDefault();
            mouseDown = true;
            startFlip(e.clientX, e.clientY);
        });
        window.addEventListener('mousemove', e => {
            if (mouseDown && isDragging) {
                moveFlip(e.clientX, e.clientY);
            }
        });
        window.addEventListener('mouseup', e => {
            if (mouseDown && isDragging) {
                endFlip();
            }
            mouseDown = false;
        });
        </script>
    </body>

</html>
